import streamlit as st
from surfire2 import generate_mlb_analysis
from pod import generate_mlb_podcast_with_audio
from pall import generate_spanish_audio
from jap import generate_japanese_audio
from firebase_config import get_auth, get_firestore
from datetime import datetime
from firebase_admin import firestore
from google.cloud import storage
import os
from google.api_core.exceptions import NotFound
import uuid
from datetime import timedelta

# Get Firebase services
auth = get_auth()
db = get_firestore()

# Constants for Google Cloud Storage
GCS_BUCKET_NAME = "mlb-podcast-bucket" # Replace this with your desired bucket name, it should be unique
GCS_LOCATION = "US" # Replace this with desired location
GCS_PROJECT = "gem-rush-007" # Replace this with your desired project ID

class UserProfile:
 def __init__(self, uid, email):
     self.uid = uid
     self.email = email
     self.db = firestore.client()
 
 def create_or_update(self, additional_data=None):
     """Creates or updates a user profile in Firestore"""
     try:
         user_ref = self.db.collection('users').document(self.uid)
         base_data = {
             'email': self.email,
             'last_login': datetime.now(),
         }
         
         # Check if this is a new user by attempting to get their profile
         existing_profile = user_ref.get()
         if not existing_profile.exists:
             base_data['account_created'] = datetime.now()
         
         # Merge additional data if provided
         if additional_data:
             base_data.update(additional_data)
         
         # Set with merge=True to update existing or create new
         user_ref.set(base_data, merge=True)
         return True
     except Exception as e:
         st.error(f"Error updating user profile: {str(e)}")
         return False

 def get_profile(self):
     """Retrieves user profile from Firestore"""
     try:
         user_ref = self.db.collection('users').document(self.uid)
         doc = user_ref.get()
         if doc.exists:
             return doc.to_dict()
         else:
             # If profile doesn't exist, create a basic one
             self.create_or_update()
             return self.get_profile()
     except Exception as e:
         st.error(f"Error fetching user profile: {str(e)}")
         return None
 
 def update_preferences(self, favorite_team=None, preferred_language=None):
     """Updates user preferences"""
     try:
         preferences = {}
         if favorite_team:
             preferences['favorite_team'] = favorite_team
         if preferred_language:
             preferences['preferred_language'] = preferred_language
         
         if preferences:
             return self.create_or_update({'preferences': preferences})
         return True
     except Exception as e:
         st.error(f"Error updating preferences: {str(e)}")
         return False
 
 def increment_podcasts_generated(self):
     """Increments the count of podcasts generated by the user"""
     try:
         user_ref = self.db.collection('users').document(self.uid)
         user_ref.update({
             'podcasts_generated': firestore.Increment(1)
         })
         return True
     except Exception as e:
         st.error(f"Error updating podcast count: {str(e)}")
         return False
 
 def get_usage_stats(self):
     """Gets usage statistics for the user"""
     try:
         profile = self.get_profile()
         if profile:
             return {
                 'podcasts_generated': profile.get('podcasts_generated', 0),
                 'account_created': profile.get('account_created', None),
                 'last_login': profile.get('last_login', None)
             }
         return None
     except Exception as e:
         st.error(f"Error fetching usage stats: {str(e)}")
         return None
 
 def store_podcast(self, signed_url):
     """Stores the podcast url in the users firestore profile"""
     try:
         user_ref = self.db.collection('users').document(self.uid)
         user_ref.update({
             'podcast_history': firestore.ArrayUnion([signed_url])
         })
         return True
     except Exception as e:
         st.error(f"Error while updating podcast url in user profile: {e}")
         return False

def handle_authentication(email, password, auth_type):
 """Enhanced authentication handler with detailed error handling"""
 try:
     if auth_type == "Sign In":
         user = auth.get_user_by_email(email)
         auth_user = auth.get_user(user.uid)
         st.session_state['user'] = auth_user
         
         # Create/update user profile
         profile = UserProfile(user.uid, email)
         profile.create_or_update()
         
         st.success(f"Welcome back, {email}!")
         return True
         
     else:  # Sign Up
         # Password validation
         if len(password) < 6:
             st.error("Password must be at least 6 characters long")
             return False
             
         user = auth.create_user(email=email, password=password)
         auth_user = auth.get_user(user.uid)
         st.session_state['user'] = auth_user
         
         # Create new user profile
         profile = UserProfile(user.uid, email)
         profile.create_or_update({
             'account_type': 'free',
             'podcasts_generated': 0
         })
         
         st.success(f"Welcome to MLB Podcast Generator, {email}!")
         return True
         
 except auth.EmailAlreadyExistsError:
     st.error("This email is already registered. Please sign in instead.")
 except auth.UserNotFoundError:
     st.error("No account found with this email. Please sign up.")
 except auth.InvalidEmailError:
     st.error("Please enter a valid email address.")
 except auth.WeakPasswordError:
     st.error("Password is too weak. Please choose a stronger password.")
 except Exception as e:
     st.error(f"Authentication error: {str(e)}")
 return False


def sign_in_or_sign_up():
 """Enhanced sign in/sign up form with validation"""
 auth_type = st.radio("Sign In or Sign Up", ["Sign In", "Sign Up"])
 
 with st.form(key='auth_form'):
     email = st.text_input("Email")
     password = st.text_input("Password", type="password")
     submit_button = st.form_submit_button(auth_type)
     
     if submit_button:
         if not email or not password:
             st.error("Please fill in all fields.")
             return
         
         if handle_authentication(email, password, auth_type):
             # Use rerun() to refresh the page after successful authentication
             st.rerun()

def handle_logout():
 """Handles user logout"""
 if st.sidebar.button("Logout"):
     # Clear all session state
     for key in list(st.session_state.keys()):
         del st.session_state[key]
     # Use the current rerun() method instead of experimental_rerun()
     st.rerun()


@st.cache_data(ttl=3600)  # Cache for 1 hour
def get_mlb_teams():
    """Fetch all current MLB teams using the analysis engine."""
    try:
        analysis_result = generate_mlb_analysis("List all current MLB teams.")
        
        # Parse teams from bullet-point format
        teams = []
        for line in analysis_result.split('\n'):
            # Look for lines starting with dash/bullet
            if line.strip().startswith('-'):
                # Extract team name and clean it
                team = line.replace('-', '').strip()
                if team:  # Only add non-empty team names
                    teams.append(team)
        
        if not teams:  # If no teams found with bullet points, try alternate parsing
            # Try splitting by commas if it's a comma-separated list
            text = analysis_result.split(':')[-1] if ':' in analysis_result else analysis_result
            text = text.replace(' and ', ', ')
            teams = [team.strip() for team in text.split(',') if team.strip()]
        
        return teams
    except Exception as e:
        st.error(f"Error fetching teams: {str(e)}")
        return []

@st.cache_data(ttl=3600)  # Cache for 1 hour
def get_players_for_team(team):
    """Fetch active players for a selected team using the analysis engine."""
    try:
        analysis_result = generate_mlb_analysis(f"List all current players on the {team} roster.")
        
        # Parse players from bullet-point format
        players = []
        for line in analysis_result.split('\n'):
            if line.strip().startswith('-'):
                player = line.replace('-', '').strip()
                if player:
                    players.append(player)
        
        if not players:  # If no players found with bullet points, try alternate parsing
            # Try splitting by commas if it's a comma-separated list
            text = analysis_result.split(':')[-1] if ':' in analysis_result else analysis_result
            text = text.replace(' and ', ', ')
            players = [player.strip() for player in text.split(',') if player.strip()]
        
        return players
    except Exception as e:
        st.error(f"Error fetching players: {str(e)}")
        return []



def create_gcs_bucket(bucket_name, location):
 """Creates a Google Cloud Storage bucket if it doesn't exist."""
 storage_client = storage.Client(project = GCS_PROJECT)
 bucket = storage_client.bucket(bucket_name)
 
 try:
   storage_client.get_bucket(bucket_name)
   print(f"Bucket with name : {bucket_name} already exist")
 except NotFound:
   print(f"Creating bucket with name: {bucket_name}")
   bucket = storage_client.create_bucket(bucket, location=location)
   print(f"Bucket {bucket} created in {location}")
 except Exception as e:
   raise Exception(f"An error has occured while creating gcs bucket, : {e}")
 
def upload_audio_to_gcs(audio_content: bytes, file_name: str) -> str:
 """Uploads audio to GCS and returns a signed URL."""
 try:
   # Create a google cloud client
   storage_client = storage.Client(project = GCS_PROJECT)
   # Create or get the bucket
   create_gcs_bucket(GCS_BUCKET_NAME, GCS_LOCATION)
   bucket = storage_client.bucket(GCS_BUCKET_NAME)
   # Upload the file
   blob = bucket.blob(file_name)
   blob.upload_from_string(audio_content, content_type="audio/mp3")
   #Generate the signed URL
   url = blob.generate_signed_url(
     version="v4",
     expiration=timedelta(minutes=15),
     method="GET"
   )
   return url
 except Exception as e:
     raise Exception(f"An error occurred while uploading audio to GCS: {e}")


def main():
 st.title("MLB Podcast Generator")
 st.write("Customize your MLB podcast by selecting your preferences below.")

 # Show logout button in sidebar if user is logged in
 if 'user' in st.session_state:
     handle_logout()
     
     # Get user profile
     profile = UserProfile(st.session_state['user'].uid, st.session_state['user'].email)
     user_data = profile.get_profile()
     
     if user_data:
         st.sidebar.write(f"Welcome, {user_data.get('email')}")
         if 'preferences' in user_data:
             st.sidebar.write("Your Preferences:")
             prefs = user_data['preferences']
             if 'favorite_team' in prefs:
                 st.sidebar.write(f"Favorite Team: {prefs['favorite_team']}")
             if 'preferred_language' in prefs:
                 st.sidebar.write(f"Preferred Language: {prefs['preferred_language']}")
            
             # Display usage statistics
             usage_stats = profile.get_usage_stats()
             if usage_stats:
                 st.write("Usage Statistics:")
                 st.write(f"Podcasts Generated: {usage_stats['podcasts_generated']}")
                 if usage_stats['account_created']:
                     st.write(f"Account Created: {usage_stats['account_created'].strftime('%Y-%m-%d')}")
 

 # If a user does not exist in the session, create authentication
 if 'user' not in st.session_state:
   sign_in_or_sign_up()
   return
 else:
   st.write(f"Logged in as: {st.session_state['user'].email}")
 
 # Fetch MLB teams
 mlb_teams = get_mlb_teams()
 
 if not mlb_teams:
     st.error("Unable to fetch MLB teams. Please try again later.")
     return

 with st.expander("Customize your podcast options", expanded=True):
     # Primary team selection
     selected_team = st.selectbox("Select Primary Team", [""] + mlb_teams)

     # Player Selection (dependent on team selection)
     selected_players = []
     if selected_team:
         available_players = get_players_for_team(selected_team)
         if available_players:
             selected_players = st.multiselect(
                 "Select players to highlight (optional)",
                 available_players
             )
         else:
             st.warning(f"Unable to fetch players for {selected_team}.")

     # Timeframe Selection
     timeframe_options = ["Last game", "Last X games", "Specific date", "Date Range"]
     selected_timeframe = st.selectbox("Select Timeframe", timeframe_options)

     timeframe_value = None
     if selected_timeframe == "Last X games":
         timeframe_value = st.number_input("Enter number of games", min_value=1, max_value=162, step=1)
     elif selected_timeframe == "Specific date":
         timeframe_value = st.date_input("Select date")
     elif selected_timeframe == "Date Range":
         col1, col2 = st.columns(2)
         with col1:
             start_date = st.date_input("Start Date")
         with col2:
             end_date = st.date_input("End Date")
         timeframe_value = (start_date, end_date)

     # Game Type Selection
     game_type_options = ["Any", "Regular season", "World Series", "Spring Training"]
     selected_game_type = st.selectbox("Select Game Type", game_type_options)

     # Opponent Team Selection
     opponent_teams = [team for team in mlb_teams if team != selected_team]
     selected_opponent = st.selectbox("Select Opponent Team (optional)", ["Any"] + opponent_teams)

     # Language selection
     language_options = ["English", "Spanish", "Japanese"]
     selected_language = st.selectbox("Select preferred language", language_options)

 if selected_team or selected_language:
     profile = UserProfile(st.session_state['user'].uid, 
                         st.session_state['user'].email)
     profile.update_preferences(selected_team, selected_language)

 # Generate Podcast Button
 if not selected_team:
     st.warning("Please select a team to generate a podcast.")
 elif st.button("Generate Podcast"):
     with st.spinner("Generating podcast..."):
         contents = construct_prompt(
             selected_team,
             selected_players,
             selected_timeframe,
             timeframe_value,
             selected_game_type,
             selected_opponent,
             selected_language
         )
         
         try:
             # Select the appropriate audio generation function based on language
             audio_file = None
             profile = UserProfile(st.session_state['user'].uid, 
                         st.session_state['user'].email)
             if selected_language.lower() == "english":
                 audio_file = generate_mlb_podcast_with_audio(
                     contents,
                     output_filename=f"podcast-{uuid.uuid4()}.mp3"
                 )
             elif selected_language.lower() == "japanese":
                  audio_file = generate_japanese_audio(
                     contents,
                     language=selected_language,
                      output_filename=f"podcast-{uuid.uuid4()}.mp3"
                 )
             elif selected_language.lower() == "spanish":
                  audio_file = generate_spanish_audio(
                     contents,
                     language=selected_language,
                     output_filename=f"podcast-{uuid.uuid4()}.mp3"
                 )
             else:
               raise ValueError(f"Unsupported language: {selected_language}")
             
             # Store the audio url
             if audio_file:
                profile.store_podcast(audio_file)
                profile.increment_podcasts_generated()
                st.audio(audio_file)
             
         except Exception as e:
             st.error(f"An error occurred while generating {selected_language} audio: {str(e)}")

def construct_prompt(selected_team, selected_players, selected_timeframe, 
                 timeframe_value, selected_game_type, selected_opponent, 
                 selected_language):
 """Constructs the prompt for the podcast agent based on user inputs."""
 prompt_parts = [f"Generate a podcast about the {selected_team}."]

 # Players
 if selected_players:
     prompt_parts.append(f"Include highlights for players: {', '.join(selected_players)}.")

 # Timeframe
 if selected_timeframe == "Last game":
     prompt_parts.append(f"Cover the last game played by the {selected_team}.")
 elif selected_timeframe == "Last X games":
     prompt_parts.append(f"Cover the last {timeframe_value} games played by the {selected_team}.")
 elif selected_timeframe == "Specific date":
     prompt_parts.append(f"Cover the {selected_team} game on {timeframe_value}.")
 elif selected_timeframe == "Date Range":
     prompt_parts.append(
         f"Cover the {selected_team} games between {timeframe_value[0]} and {timeframe_value[1]}."
     )

 # Game Type
 if selected_game_type != "Any":
     prompt_parts.append(f"Focus on {selected_game_type.lower()} games.")

 # Opponent Team
 if selected_opponent != "Any":
     prompt_parts.append(f"Specifically include games against {selected_opponent}.")

 # Language
 prompt_parts.append(f"Generate the podcast script in {selected_language}.")

 return " ".join(prompt_parts)

if __name__ == "__main__":
 main()