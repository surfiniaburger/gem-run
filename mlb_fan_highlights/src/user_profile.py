from datetime import datetime
from typing import Dict, Optional, Any, List
from firebase_admin import firestore
import logging

class UserProfile:
    """
    Manages user profile data and interactions with Firestore database.
    
    Attributes:
        uid (str): User's unique identifier
        email (str): User's email address
        db (firestore.Client): Firestore client instance
    """
    
    def __init__(self, uid: str, email: str):
        """
        Initialize a UserProfile instance.
        
        Args:
            uid: User's unique identifier
            email: User's email address
        """
        self.uid = uid
        self.email = email
        self.db = firestore.client()
        self._user_ref = self.db.collection('users').document(uid)

    def create_or_update(self, additional_data: Optional[Dict[str, Any]] = None) -> bool:
        """
        Creates or updates a user profile in Firestore.
        
        Args:
            additional_data: Optional dictionary of additional user data to store
            
        Returns:
            bool: True if operation was successful, False otherwise
        """
        try:
            base_data = {
                'email': self.email,
                'last_login': datetime.now(),
            }
            
            # Check if this is a new user
            existing_profile = self._user_ref.get()
            if not existing_profile.exists:
                base_data['account_created'] = datetime.now()
                base_data['account_type'] = 'free'
                base_data['podcasts_generated'] = 0
            
            if additional_data:
                base_data.update(additional_data)
            
            self._user_ref.set(base_data, merge=True)
            logging.info(f"Profile updated successfully for user {self.uid}")
            return True
            
        except Exception as e:
            logging.error(f"Error updating user profile for {self.uid}: {str(e)}")
            return False

    def get_profile(self) -> Optional[Dict[str, Any]]:
        """
        Retrieves user profile from Firestore.
        
        Returns:
            Optional[Dict[str, Any]]: User profile data or None if error occurs
        """
        try:
            doc = self._user_ref.get()
            if doc.exists:
                return doc.to_dict()
            else:
                # Create basic profile if it doesn't exist
                self.create_or_update()
                return self.get_profile()
                
        except Exception as e:
            logging.error(f"Error fetching user profile for {self.uid}: {str(e)}")
            return None

    def update_preferences(self, favorite_team: Optional[str] = None, 
                         preferred_language: Optional[str] = None) -> bool:
        """
        Updates user preferences in Firestore.
        
        Args:
            favorite_team: Optional favorite MLB team
            preferred_language: Optional preferred podcast language
            
        Returns:
            bool: True if update was successful, False otherwise
        """
        try:
            preferences = {}
            if favorite_team:
                preferences['favorite_team'] = favorite_team
            if preferred_language:
                preferences['preferred_language'] = preferred_language
            
            if preferences:
                return self.create_or_update({'preferences': preferences})
            return True
            
        except Exception as e:
            logging.error(f"Error updating preferences for {self.uid}: {str(e)}")
            return False

    def increment_podcasts_generated(self) -> bool:
        """
        Increments the count of podcasts generated by the user.
        
        Returns:
            bool: True if increment was successful, False otherwise
        """
        try:
            self._user_ref.update({
                'podcasts_generated': firestore.Increment(1)
            })
            logging.info(f"Podcasts generated incremented for user {self.uid}")
            return True
            
        except Exception as e:
            logging.error(f"Error incrementing podcast count for {self.uid}: {str(e)}")
            return False

    def get_usage_stats(self) -> Optional[Dict[str, Any]]:
        """
        Gets usage statistics for the user.
        
        Returns:
            Optional[Dict[str, Any]]: Dictionary containing usage statistics or None if error occurs
        """
        try:
            profile = self.get_profile()
            if profile:
                return {
                    'podcasts_generated': profile.get('podcasts_generated', 0),
                    'account_created': profile.get('account_created', None),
                    'last_login': profile.get('last_login', None)
                }
            return None
            
        except Exception as e:
            logging.error(f"Error fetching usage stats for {self.uid}: {str(e)}")
            return None

    def store_podcast(self, signed_url: str) -> bool:
        """
        Stores the podcast URL in the user's Firestore profile.
        
        Args:
            signed_url: The signed URL for the generated podcast
            
        Returns:
            bool: True if storage was successful, False otherwise
        """
        try:
            podcast_entry = {
                'url': signed_url,
                'generated_at': datetime.now()
            }
            
            # Get current history from document data
            doc = self._user_ref.get()
            if doc.exists:
                data = doc.to_dict()
                current_history = data.get('podcast_history', [])
            else:
                current_history = []

            # Add new entry
            current_history.append(podcast_entry)
            
            # Update document
            self._user_ref.update({
                'podcast_history': current_history
            })
            
            logging.info(f"Podcast URL stored for user {self.uid}")
            return True
            
        except Exception as e:
            logging.error(f"Error storing podcast URL for {self.uid}: {str(e)}")
            return False

    def get_podcast_history(self) -> List[Dict[str, Any]]:
        """
        Retrieves the user's podcast generation history.
        
        Returns:
            List[Dict[str, Any]]: List of podcast entries with URLs and timestamps
        """
        try:
            profile = self.get_profile()
            if profile and 'podcast_history' in profile:
                return profile['podcast_history']
            return []
            
        except Exception as e:
            logging.error(f"Error fetching podcast history for {self.uid}: {str(e)}")
            return []

    def check_usage_limits(self) -> Dict[str, Any]:
        """
        Checks user's usage against their account limits.
        
        Returns:
            Dict[str, Any]: Dictionary containing usage status and limits
        """
        try:
            profile = self.get_profile()
            account_type = profile.get('account_type', 'free')
            podcasts_generated = profile.get('podcasts_generated', 0)
            
            limits = {
                'free': {'daily': 200, 'monthly': 500},
                'premium': {'daily': 100, 'monthly': 900}
            }
            
            current_limits = limits.get(account_type, limits['free'])
            
            # Get today's usage
            today = datetime.now().date()
            today_start = datetime.combine(today, datetime.min.time())
            
            # Get podcast history for today
            history = self.get_podcast_history()
            daily_podcasts = [
                podcast for podcast in history
                if isinstance(podcast.get('generated_at'), datetime) and 
                podcast['generated_at'].date() == today
            ]
            
            return {
                'account_type': account_type,
                'total_generated': podcasts_generated,
                'daily_limit': current_limits['daily'],
                'monthly_limit': current_limits['monthly'],
                'daily_used': len(daily_podcasts),
                'can_generate': len(daily_podcasts) < current_limits['daily']
            }
            
        except Exception as e:
            logging.error(f"Error checking usage limits for {self.uid}: {str(e)}")
            return {
                'account_type': 'free',
                'can_generate': False,
                'error': str(e)
            }


    def save_feedback(self, feedback_data: Dict[str, Any]) -> bool:
        """
        Saves user feedback to Firestore.
        
        Args:
            feedback_data: Dictionary containing feedback data (e.g., rating, comments)
            
        Returns:
            bool: True if feedback was saved successfully, False otherwise
        """
        try:
            feedback_entry = {
                **feedback_data,
                'submitted_at': datetime.now()
            }
            
            # Get current feedback history from document data
            doc = self._user_ref.get()
            if doc.exists:
                data = doc.to_dict()
                current_feedback = data.get('feedback_history', [])
            else:
                current_feedback = []

            # Add new feedback entry
            current_feedback.append(feedback_entry)
            
            # Update document
            self._user_ref.update({
                'feedback_history': current_feedback
            })
            
            logging.info(f"Feedback saved for user {self.uid}")
            return True
            
        except Exception as e:
            logging.error(f"Error saving feedback for {self.uid}: {str(e)}")
            return False